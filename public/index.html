<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Roku Visual</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link
      href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Archivo+Black&display=swap"
      rel="stylesheet"
    />
    <style>
      *,
      *::before,
      *::after {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      :root {
        --bg: #050508;
        --fg: #e8e8f0;
        --accent: hsl(var(--hue, 200), 80%, 60%);
        --dim: rgba(232, 232, 240, 0.18);
        --hue: 200;
      }

      body {
        background: var(--bg);
        color: var(--fg);
        font-family: 'Share Tech Mono', monospace;
        overflow: hidden;
        height: 100dvh;
        width: 100dvw;
        cursor: none;
      }

      canvas {
        position: fixed;
        inset: 0;
        display: block;
      }

      /* HUD overlay */
      #hud {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        display: flex;
        align-items: flex-start;
        justify-content: space-between;
        padding: 18px 24px;
        pointer-events: none;
        z-index: 10;
      }

      .hud-block {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      .hud-block.center {
        position: fixed;
        left: 50%;
        transform: translateX(-50%);
      }

      .hud-label {
        font-size: 9px;
        letter-spacing: 0.2em;
        text-transform: uppercase;
        color: var(--dim);
      }

      .hud-value {
        font-size: 13px;
        color: hsl(var(--hue), 75%, 65%);
        transition: color 0.3s;
      }

      #mode-badge {
        font-family: 'Archivo Black', sans-serif;
        font-size: 11px;
        letter-spacing: 0.3em;
        text-transform: uppercase;
        padding: 4px 10px;
        border: 1px solid hsl(var(--hue), 70%, 40%);
        color: hsl(var(--hue), 80%, 70%);
        background: hsla(var(--hue), 60%, 10%, 0.6);
        backdrop-filter: blur(4px);
        transition: all 0.4s;
      }

      /* Button flash */
      #btn-flash {
        position: fixed;
        bottom: 24px;
        left: 50%;
        transform: translateX(-50%);
        font-family: 'Archivo Black', sans-serif;
        font-size: 28px;
        letter-spacing: 0.15em;
        color: hsl(var(--hue), 90%, 70%);
        text-shadow: 0 0 40px hsl(var(--hue), 100%, 50%);
        opacity: 0;
        transition: opacity 0.1s;
        pointer-events: none;
        z-index: 20;
      }

      /* Status dot */
      #status {
        width: 7px;
        height: 7px;
        border-radius: 50%;
        background: #ff3a3a;
        display: inline-block;
        margin-right: 6px;
        transition: background 0.4s;
      }
      #status.ok {
        background: #3aff8a;
        box-shadow: 0 0 8px #3aff8a;
      }

      /* Remote control overlay (keyboard/on-screen) */
      #remote {
        position: fixed;
        right: 20px;
        bottom: 20px;
        z-index: 30;
        display: grid;
        grid-template-columns: repeat(3, 38px);
        grid-template-rows: repeat(5, 38px);
        gap: 5px;
        opacity: 0.55;
        transition: opacity 0.3s;
      }
      #remote:hover {
        opacity: 0.95;
      }

      .rkey {
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-radius: 6px;
        font-size: 12px;
        cursor: pointer;
        user-select: none;
        transition:
          background 0.1s,
          border-color 0.1s,
          transform 0.1s;
        color: var(--fg);
      }
      .rkey:active,
      .rkey.pressed {
        background: hsla(var(--hue), 60%, 30%, 0.5);
        border-color: hsl(var(--hue), 80%, 50%);
        transform: scale(0.92);
      }
      .rkey.span2 {
        grid-column: span 2;
      }
      .rkey.center {
        grid-column: 2;
        border-radius: 50%;
        width: 38px;
        height: 38px;
      }
      .rkey-spacer {
        visibility: hidden;
      }

      /* Log panel */
      #log-panel {
        position: fixed;
        left: 20px;
        bottom: 20px;
        width: 380px;
        max-height: 220px;
        background: rgba(5, 5, 8, 0.85);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 8px;
        padding: 10px;
        font-size: 11px;
        overflow-y: auto;
        z-index: 40;
        backdrop-filter: blur(6px);
      }
      #log-panel::-webkit-scrollbar {
        width: 6px;
      }
      #log-panel::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.2);
        border-radius: 3px;
      }

      .log-entry {
        display: flex;
        gap: 8px;
        padding: 3px 0;
        border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      }
      .log-entry:last-child {
        border-bottom: none;
      }
      .log-ts {
        color: #666;
        min-width: 72px;
      }
      .log-level {
        min-width: 42px;
        text-transform: uppercase;
        font-size: 9px;
        letter-spacing: 0.05em;
        padding: 1px 4px;
        border-radius: 3px;
      }
      .log-level.info {
        color: #6af;
      }
      .log-level.ecp {
        color: #fa6;
      }
      .log-level.button {
        color: #6f6;
      }
      .log-level.warn {
        color: #fd6;
      }
      .log-level.error {
        color: #f66;
        background: rgba(255, 100, 100, 0.15);
      }
      .log-msg {
        color: #ddd;
        word-break: break-all;
      }
      .log-detail {
        color: #888;
        font-size: 10px;
      }
    </style>
  </head>
  <body>
    <canvas id="c"></canvas>

    <!-- HUD -->
    <div id="hud">
      <div class="hud-block">
        <span class="hud-label"><span id="status"></span>Roku</span>
        <span class="hud-value" id="hud-app">—</span>
        <span class="hud-value" id="hud-power" style="font-size: 10px; opacity: 0.5"></span>
      </div>
      <div class="hud-block center">
        <div id="mode-badge">lissajous</div>
      </div>
      <div class="hud-block" style="align-items: flex-end">
        <span class="hud-label">params</span>
        <span class="hud-value" id="hud-params">—</span>
      </div>
    </div>

    <div id="btn-flash"></div>

    <!-- Log panel -->
    <div id="log-panel"></div>

    <!-- On-screen remote (also accepts keyboard) -->
    <div id="remote">
      <!-- Row 1 -->
      <div class="rkey rkey-spacer"></div>
      <div class="rkey" data-key="Up">▲</div>
      <div class="rkey rkey-spacer"></div>
      <!-- Row 2 -->
      <div class="rkey" data-key="Left">◀</div>
      <div class="rkey center" data-key="Select">OK</div>
      <div class="rkey" data-key="Right">▶</div>
      <!-- Row 3 -->
      <div class="rkey rkey-spacer"></div>
      <div class="rkey" data-key="Down">▼</div>
      <div class="rkey rkey-spacer"></div>
      <!-- Row 4 -->
      <div class="rkey" data-key="Rev">⏮</div>
      <div class="rkey" data-key="Play">⏯</div>
      <div class="rkey" data-key="Fwd">⏭</div>
      <!-- Row 5 -->
      <div class="rkey" data-key="Back">↩</div>
      <div class="rkey" data-key="Home">⌂</div>
      <div class="rkey" data-key="Info">✦</div>
    </div>

    <script>
      // ── WebSocket ─────────────────────────────────────────────────────────────────
      const WS_URL = `ws://${location.host}`;
      let ws,
        params = {
          hue: 200,
          speed: 1.0,
          complexity: 3,
          scale: 1.0,
          mode: 'lissajous',
          colorShift: false
        };
      const logs = [];

      function connect() {
        ws = new WebSocket(WS_URL);
        ws.onopen = () => console.log('[ws] connected');
        ws.onclose = () => setTimeout(connect, 2000);
        ws.onmessage = (e) => {
          const msg = JSON.parse(e.data);
          if (msg.type === 'state') applyState(msg.state);
          if (msg.type === 'button') {
            params = msg.params;
            flashButton(msg.key);
            syncHUD();
          }
          if (msg.type === 'log') {
            addLogEntry(msg.entry);
          }
        };
      }
      connect();

      function addLogEntry(entry) {
        logs.push(entry);
        renderLogEntry(entry);
        // Keep DOM limited
        const panel = document.getElementById('log-panel');
        while (panel.children.length > 50) {
          panel.removeChild(panel.firstChild);
        }
      }

      function renderLogEntry(entry) {
        const panel = document.getElementById('log-panel');
        const div = document.createElement('div');
        div.className = 'log-entry';

        const ts = entry.ts.slice(11, 23);
        const level = entry.level;
        const msg = entry.message;
        const detail = entry.detail ? `<span class="log-detail">${entry.detail}</span>` : '';

        div.innerHTML = `
    <span class="log-ts">${ts}</span>
    <span class="log-level ${level}">${level}</span>
    <span class="log-msg">${msg}</span>
    ${detail}
  `;

        panel.insertBefore(div, panel.firstChild);
      }

      function sendKey(key) {
        // Send via WebSocket (server will also forward to Roku ECP)
        if (ws && ws.readyState === 1) ws.send(JSON.stringify({ type: 'keypress', key }));
      }

      function applyState(s) {
        params = s.params;
        document.getElementById('status').className = s.connected ? 'ok' : '';
        document.getElementById('hud-app').textContent = s.activeApp || '—';
        document.getElementById('hud-power').textContent = s.powerMode || '';
        // Render any logs that came with state
        if (s.logs && s.logs.length) {
          s.logs.forEach((log) => {
            if (!logs.find((l) => l.ts === log.ts)) renderLogEntry(log);
          });
        }
        syncHUD();
      }

      function syncHUD() {
        document.documentElement.style.setProperty('--hue', params.hue);
        document.getElementById('mode-badge').textContent = params.mode;
        document.getElementById('hud-params').textContent =
          `spd ${params.speed.toFixed(2)}  cmp ${params.complexity}  scl ${params.scale.toFixed(1)}`;
      }

      // ── Button flash ──────────────────────────────────────────────────────────────
      let flashTimer;
      function flashButton(key) {
        const el = document.getElementById('btn-flash');
        el.textContent = key.toUpperCase();
        el.style.opacity = '1';
        clearTimeout(flashTimer);
        flashTimer = setTimeout(() => (el.style.opacity = '0'), 600);
      }

      // ── On-screen remote ──────────────────────────────────────────────────────────
      document.querySelectorAll('.rkey[data-key]').forEach((btn) => {
        btn.addEventListener('pointerdown', () => {
          btn.classList.add('pressed');
          sendKey(btn.dataset.key);
        });
        btn.addEventListener('pointerup', () => btn.classList.remove('pressed'));
      });

      // Keyboard mapping
      const KB_MAP = {
        ArrowUp: 'Up',
        ArrowDown: 'Down',
        ArrowLeft: 'Left',
        ArrowRight: 'Right',
        Enter: 'Select',
        Backspace: 'Back',
        Escape: 'Home',
        ' ': 'Play',
        '>': 'Fwd',
        '<': 'Rev',
        '*': 'Info',
        '+': 'VolumeUp',
        '-': 'VolumeDown'
      };
      document.addEventListener('keydown', (e) => {
        const key = KB_MAP[e.key];
        if (key) {
          e.preventDefault();
          sendKey(key);
        }
      });

      // ── Canvas ────────────────────────────────────────────────────────────────────
      const canvas = document.getElementById('c');
      const ctx = canvas.getContext('2d');
      let W,
        H,
        cx,
        cy,
        t = 0;

      function resize() {
        W = canvas.width = window.innerWidth;
        H = canvas.height = window.innerHeight;
        cx = W / 2;
        cy = H / 2;
      }
      window.addEventListener('resize', resize);
      resize();

      // Trail buffer
      let trail = [];
      const MAX_TRAIL = 1800;

      // Particle pool (for particles mode)
      const PARTICLES = Array.from({ length: 120 }, () => ({
        x: 0,
        y: 0,
        vx: 0,
        vy: 0,
        life: 0,
        maxLife: 0,
        hue: 0
      }));

      function resetParticle(p, x, y) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 0.5 + Math.random() * 3;
        p.x = x;
        p.y = y;
        p.vx = Math.cos(angle) * speed;
        p.vy = Math.sin(angle) * speed;
        p.life = 0;
        p.maxLife = 40 + Math.random() * 80;
        p.hue = params.hue;
      }

      // Draw the current shape at time t, return {x, y}
      function shapePt(t) {
        const { mode, complexity: n, scale, speed } = params;
        const s = Math.min(W, H) * 0.38 * scale;
        const st = t * speed;

        switch (mode) {
          case 'lissajous': {
            const a = n,
              b = n + 1;
            return { x: cx + s * Math.sin(a * st + Math.PI / 4), y: cy + s * Math.sin(b * st) };
          }
          case 'rose': {
            const r = s * Math.sin(n * st);
            return { x: cx + r * Math.cos(st), y: cy + r * Math.sin(st) };
          }
          case 'spirograph': {
            const R = s * 0.7,
              r = R / (n + 1),
              d = r * 0.8;
            return {
              x: cx + (R - r) * Math.cos(st) + d * Math.cos(((R - r) / r) * st),
              y: cy + (R - r) * Math.sin(st) - d * Math.sin(((R - r) / r) * st)
            };
          }
          case 'wave': {
            const x = cx + s * Math.sin(st);
            const y = cy + s * Math.sin(n * st + Math.PI / n);
            return { x, y };
          }
          case 'particles': {
            // Just return a point on a circle for particle source
            const r = s * 0.5;
            return { x: cx + r * Math.cos(st), y: cy + r * Math.sin(n * st) };
          }
          default:
            return { x: cx, y: cy };
        }
      }

      // ── Render ────────────────────────────────────────────────────────────────────
      let lastPt = null;

      function frame() {
        requestAnimationFrame(frame);
        t += 0.008;

        const { hue, colorShift, mode } = params;
        const dynHue = colorShift ? (hue + t * 30) % 360 : hue;

        // Fade background
        ctx.fillStyle = 'rgba(5,5,8,0.18)';
        ctx.fillRect(0, 0, W, H);

        const pt = shapePt(t);

        if (mode === 'particles') {
          // Emit particles from shape point
          if (Math.random() < 0.6) {
            const free = PARTICLES.find((p) => p.life >= p.maxLife);
            if (free) resetParticle(free, pt.x, pt.y);
          }
          // Render particles
          for (const p of PARTICLES) {
            if (p.life >= p.maxLife) continue;
            p.life++;
            p.x += p.vx;
            p.y += p.vy;
            p.vy += 0.04; // gravity
            const alpha = 1 - p.life / p.maxLife;
            const size = (1 - p.life / p.maxLife) * 4 + 0.5;
            ctx.beginPath();
            ctx.arc(p.x, p.y, size, 0, Math.PI * 2);
            ctx.fillStyle = `hsla(${dynHue + p.life * 2}, 90%, 65%, ${alpha})`;
            ctx.fill();
          }
          // Draw source dot
          ctx.beginPath();
          ctx.arc(pt.x, pt.y, 6, 0, Math.PI * 2);
          ctx.fillStyle = `hsl(${dynHue}, 100%, 75%)`;
          ctx.shadowColor = `hsl(${dynHue}, 100%, 60%)`;
          ctx.shadowBlur = 20;
          ctx.fill();
          ctx.shadowBlur = 0;
        } else {
          // Trail-based modes
          trail.push({ ...pt, hue: dynHue });
          if (trail.length > MAX_TRAIL) trail.shift();

          // Draw trail as line segments with gradient alpha
          if (trail.length > 2) {
            const len = trail.length;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            for (let i = 1; i < len; i++) {
              const t0 = trail[i - 1],
                t1 = trail[i];
              const progress = i / len;
              const alpha = Math.pow(progress, 1.4) * 0.9;
              const lw = progress * 2.5 + 0.3;
              const h = colorShift ? (t1.hue + progress * 60) % 360 : t1.hue;

              ctx.beginPath();
              ctx.moveTo(t0.x, t0.y);
              ctx.lineTo(t1.x, t1.y);
              ctx.strokeStyle = `hsla(${h}, 85%, 60%, ${alpha})`;
              ctx.lineWidth = lw;
              ctx.stroke();
            }
          }

          // Glowing head
          const grd = ctx.createRadialGradient(pt.x, pt.y, 0, pt.x, pt.y, 14);
          grd.addColorStop(0, `hsla(${dynHue}, 100%, 90%, 1)`);
          grd.addColorStop(0.4, `hsla(${dynHue}, 100%, 65%, 0.6)`);
          grd.addColorStop(1, `hsla(${dynHue}, 100%, 50%, 0)`);
          ctx.beginPath();
          ctx.arc(pt.x, pt.y, 14, 0, Math.PI * 2);
          ctx.fillStyle = grd;
          ctx.fill();
        }

        lastPt = pt;

        // Grid lines (very subtle)
        if (t % 1 < 0.008) {
          // subtle grid pulse on cycle
        }

        // Scanline overlay (every other pixel row, barely visible)
        // (skip for perf – handled by CSS layer if desired)
      }

      frame();
    </script>
  </body>
</html>
