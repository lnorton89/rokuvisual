<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Roku Visual</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link
      href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Archivo+Black&display=swap"
      rel="stylesheet"
    />
    <style>
      *,
      *::before,
      *::after {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      :root {
        --bg: #050508;
        --fg: #e8e8f0;
        --accent: hsl(var(--hue, 200), 80%, 60%);
        --dim: rgba(232, 232, 240, 0.18);
        --hue: 200;
      }

      body {
        background: var(--bg);
        color: var(--fg);
        font-family: 'Share Tech Mono', monospace;
        overflow: hidden;
        height: 100dvh;
        width: 100dvw;
        cursor: default;
      }

      canvas {
        position: fixed;
        inset: 0;
        display: block;
      }

      /* HUD overlay */
      #hud {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        display: flex;
        align-items: flex-start;
        justify-content: space-between;
        padding: 18px 24px;
        pointer-events: none;
        z-index: 10;
      }

      .hud-block {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      .hud-block.center {
        position: fixed;
        left: 50%;
        transform: translateX(-50%);
      }

      .hud-label {
        font-size: 9px;
        letter-spacing: 0.2em;
        text-transform: uppercase;
        color: var(--dim);
      }

      .hud-value {
        font-size: 13px;
        color: hsl(var(--hue), 75%, 65%);
        transition: color 0.3s;
      }

      #mode-badge {
        font-family: 'Archivo Black', sans-serif;
        font-size: 11px;
        letter-spacing: 0.3em;
        text-transform: uppercase;
        padding: 4px 10px;
        border: 1px solid hsl(var(--hue), 70%, 40%);
        color: hsl(var(--hue), 80%, 70%);
        background: hsla(var(--hue), 60%, 10%, 0.6);
        backdrop-filter: blur(4px);
        transition: all 0.4s;
      }

      /* Button flash */
      #btn-flash {
        position: fixed;
        bottom: 24px;
        left: 50%;
        transform: translateX(-50%);
        font-family: 'Archivo Black', sans-serif;
        font-size: 28px;
        letter-spacing: 0.15em;
        color: hsl(var(--hue), 90%, 70%);
        text-shadow: 0 0 40px hsl(var(--hue), 100%, 50%);
        opacity: 0;
        transition: opacity 0.1s;
        pointer-events: none;
        z-index: 20;
      }

      /* Status dot */
      #status {
        width: 7px;
        height: 7px;
        border-radius: 50%;
        background: #ff3a3a;
        display: inline-block;
        margin-right: 6px;
        transition: background 0.4s;
      }
      #status.ok {
        background: #3aff8a;
        box-shadow: 0 0 8px #3aff8a;
      }

      /* Remote control overlay (keyboard/on-screen) */
      #remote {
        position: fixed;
        right: 20px;
        bottom: 20px;
        z-index: 30;
        display: grid;
        grid-template-columns: repeat(3, 38px);
        grid-template-rows: repeat(5, 38px);
        gap: 5px;
        opacity: 0.55;
        transition: opacity 0.3s;
      }
      #remote:hover {
        opacity: 0.95;
      }

      .rkey {
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.12);
        border-radius: 6px;
        font-size: 12px;
        cursor: pointer;
        user-select: none;
        transition:
          background 0.1s,
          border-color 0.1s,
          transform 0.1s;
        color: var(--fg);
      }
      .rkey:active,
      .rkey.pressed {
        background: hsla(var(--hue), 60%, 30%, 0.5);
        border-color: hsl(var(--hue), 80%, 50%);
        transform: scale(0.92);
      }
      .rkey.span2 {
        grid-column: span 2;
      }
      .rkey.center {
        grid-column: 2;
        border-radius: 50%;
        width: 38px;
        height: 38px;
      }
      .rkey-spacer {
        visibility: hidden;
      }

      /* Log panel */
      #log-panel {
        position: fixed;
        left: 20px;
        bottom: 20px;
        width: 380px;
        max-height: 220px;
        background: rgba(5, 5, 8, 0.85);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 8px;
        padding: 10px;
        font-size: 11px;
        overflow-y: auto;
        z-index: 40;
        backdrop-filter: blur(6px);
      }
      #log-panel::-webkit-scrollbar {
        width: 6px;
      }
      #log-panel::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.2);
        border-radius: 3px;
      }

      .log-entry {
        display: flex;
        gap: 8px;
        padding: 3px 0;
        border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      }
      .log-entry:last-child {
        border-bottom: none;
      }
      .log-ts {
        color: #666;
        min-width: 72px;
      }
      .log-level {
        min-width: 42px;
        text-transform: uppercase;
        font-size: 9px;
        letter-spacing: 0.05em;
        padding: 1px 4px;
        border-radius: 3px;
      }
      .log-level.info {
        color: #6af;
      }
      .log-level.ecp {
        color: #fa6;
      }
      .log-level.button {
        color: #6f6;
      }
      .log-level.warn {
        color: #fd6;
      }
      .log-level.error {
        color: #f66;
        background: rgba(255, 100, 100, 0.15);
      }
      .log-msg {
        color: #ddd;
        word-break: break-all;
      }
      .log-detail {
        color: #888;
        font-size: 10px;
      }

      /* Cast panel */
      #cast-panel {
        position: fixed;
        right: 20px;
        top: 80px;
        width: 280px;
        background: rgba(5, 5, 8, 0.9);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 10px;
        padding: 12px;
        z-index: 35;
        backdrop-filter: blur(8px);
        display: none;
      }
      #cast-panel.visible {
        display: block;
      }
      .cast-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 10px;
      }
      .cast-title {
        font-size: 12px;
        font-weight: bold;
        color: hsl(var(--hue), 80%, 60%);
        letter-spacing: 0.1em;
        text-transform: uppercase;
      }
      .cast-close {
        background: none;
        border: none;
        color: #666;
        cursor: pointer;
        font-size: 18px;
        padding: 0 5px;
      }
      .cast-close:hover {
        color: #fff;
      }
      .cast-row {
        display: flex;
        gap: 8px;
        margin-bottom: 8px;
      }
      .cast-input {
        flex: 1;
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 5px;
        padding: 6px 10px;
        color: #fff;
        font-size: 12px;
        font-family: 'Share Tech Mono', monospace;
      }
      .cast-input::placeholder {
        color: #666;
      }
      .cast-btn {
        background: hsl(var(--hue), 70%, 40%);
        border: none;
        border-radius: 5px;
        padding: 6px 12px;
        color: #fff;
        font-size: 11px;
        cursor: pointer;
        transition: all 0.2s;
        font-family: 'Share Tech Mono', monospace;
        text-transform: uppercase;
        letter-spacing: 0.05em;
      }
      .cast-btn:hover:not(:disabled) {
        background: hsl(var(--hue), 80%, 50%);
      }
      .cast-btn:disabled {
        opacity: 0.4;
        cursor: not-allowed;
      }
      .cast-status {
        font-size: 10px;
        color: #666;
        margin-top: 8px;
        display: flex;
        align-items: center;
        gap: 6px;
      }
      .cast-status-dot {
        width: 6px;
        height: 6px;
        border-radius: 50%;
        background: #444;
      }
      .cast-status-dot.ok {
        background: #27c527;
        box-shadow: 0 0 6px #27c527;
      }
      .cast-status-dot.error {
        background: #c52727;
      }
      #cast-toggle {
        position: fixed;
        right: 20px;
        top: 20px;
        background: hsl(var(--hue), 70%, 40%);
        border: none;
        border-radius: 8px;
        padding: 8px 14px;
        color: #fff;
        cursor: pointer;
        font-size: 12px;
        z-index: 36;
        font-family: 'Share Tech Mono', monospace;
        text-transform: uppercase;
        letter-spacing: 0.1em;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        gap: 6px;
      }
      #cast-toggle:hover {
        background: hsl(var(--hue), 80%, 50%);
      }
      .cast-icon {
        font-size: 14px;
      }
    </style>
  </head>
  <body>
    <canvas id="c"></canvas>

    <!-- Cast toggle button -->
    <button id="cast-toggle">
      <span class="cast-icon">üì∫</span>
      <span>Cast</span>
    </button>

    <!-- Cast panel -->
    <div id="cast-panel">
      <div class="cast-header">
        <span class="cast-title">Roku Cast</span>
        <button class="cast-close" id="cast-close">√ó</button>
      </div>
      <div class="cast-row">
        <input
          type="text"
          id="roku-ip-input"
          class="cast-input"
          placeholder="Roku IP (e.g., 192.168.1.155)"
        />
        <button class="cast-btn" id="cast-save-ip">Save</button>
      </div>
      <div class="cast-row">
        <input
          type="text"
          id="media-url-input"
          class="cast-input"
          placeholder="Media URL (HLS/MP4)"
        />
      </div>
      <div class="cast-row">
        <input
          type="text"
          id="media-title-input"
          class="cast-input"
          placeholder="Title (optional)"
        />
      </div>
      <div class="cast-row">
        <button class="cast-btn" id="cast-send-btn" style="flex: 1">Cast to Roku</button>
      </div>
      <div class="cast-status">
        <span class="cast-status-dot" id="cast-status-dot"></span>
        <span id="cast-status-text">Not connected</span>
      </div>
    </div>

    <!-- HUD -->
    <div id="hud">
      <div class="hud-block">
        <span class="hud-label"><span id="status"></span>Roku</span>
        <span class="hud-value" id="hud-app">‚Äî</span>
        <span class="hud-value" id="hud-power" style="font-size: 10px; opacity: 0.5"></span>
      </div>
      <div class="hud-block center">
        <div id="mode-badge">lissajous</div>
      </div>
      <div class="hud-block" style="align-items: flex-end">
        <span class="hud-label">params</span>
        <span class="hud-value" id="hud-params">‚Äî</span>
      </div>
    </div>

    <div id="btn-flash"></div>

    <!-- Log panel -->
    <div id="log-panel"></div>

    <!-- On-screen remote (also accepts keyboard) -->
    <div id="remote">
      <!-- Row 1 -->
      <div class="rkey rkey-spacer"></div>
      <div class="rkey" data-key="Up">‚ñ≤</div>
      <div class="rkey rkey-spacer"></div>
      <!-- Row 2 -->
      <div class="rkey" data-key="Left">‚óÄ</div>
      <div class="rkey center" data-key="Select">OK</div>
      <div class="rkey" data-key="Right">‚ñ∂</div>
      <!-- Row 3 -->
      <div class="rkey rkey-spacer"></div>
      <div class="rkey" data-key="Down">‚ñº</div>
      <div class="rkey rkey-spacer"></div>
      <!-- Row 4 -->
      <div class="rkey" data-key="Rev">‚èÆ</div>
      <div class="rkey" data-key="Play">‚èØ</div>
      <div class="rkey" data-key="Fwd">‚è≠</div>
      <!-- Row 5 -->
      <div class="rkey" data-key="Back">‚Ü©</div>
      <div class="rkey" data-key="Home">‚åÇ</div>
      <div class="rkey" data-key="Info">‚ú¶</div>
    </div>

    <script>
      // ‚îÄ‚îÄ WebSocket ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      const WS_URL = `ws://${location.host}`;
      let ws,
        params = {
          hue: 200,
          speed: 1.0,
          complexity: 3,
          scale: 1.0,
          mode: 'lissajous',
          colorShift: false
        };
      const logs = [];

      function connect() {
        ws = new WebSocket(WS_URL);
        ws.onopen = () => console.log('[ws] connected');
        ws.onclose = () => setTimeout(connect, 2000);
        ws.onmessage = (e) => {
          const msg = JSON.parse(e.data);
          if (msg.type === 'state') applyState(msg.state);
          if (msg.type === 'button') {
            params = msg.params;
            flashButton(msg.key);
            syncHUD();
          }
          if (msg.type === 'log') {
            addLogEntry(msg.entry);
          }
        };
      }
      connect();

      function addLogEntry(entry) {
        logs.push(entry);
        renderLogEntry(entry);
        // Keep DOM limited
        const panel = document.getElementById('log-panel');
        while (panel.children.length > 50) {
          panel.removeChild(panel.firstChild);
        }
      }

      function renderLogEntry(entry) {
        const panel = document.getElementById('log-panel');
        const div = document.createElement('div');
        div.className = 'log-entry';

        const ts = entry.ts.slice(11, 23);
        const level = entry.level;
        const msg = entry.message;
        const detail = entry.detail ? `<span class="log-detail">${entry.detail}</span>` : '';

        div.innerHTML = `
    <span class="log-ts">${ts}</span>
    <span class="log-level ${level}">${level}</span>
    <span class="log-msg">${msg}</span>
    ${detail}
  `;

        panel.insertBefore(div, panel.firstChild);
      }

      function sendKey(key) {
        // Send via WebSocket (server will also forward to Roku ECP)
        if (ws && ws.readyState === 1) ws.send(JSON.stringify({ type: 'keypress', key }));
      }

      function applyState(s) {
        params = s.params;
        document.getElementById('status').className = s.connected ? 'ok' : '';
        document.getElementById('hud-app').textContent = s.activeApp || '‚Äî';
        document.getElementById('hud-power').textContent = s.powerMode || '';
        // Render any logs that came with state
        if (s.logs && s.logs.length) {
          s.logs.forEach((log) => {
            if (!logs.find((l) => l.ts === log.ts)) renderLogEntry(log);
          });
        }
        syncHUD();
      }

      function syncHUD() {
        document.documentElement.style.setProperty('--hue', params.hue);
        document.getElementById('mode-badge').textContent = params.mode;
        document.getElementById('hud-params').textContent =
          `spd ${params.speed.toFixed(2)}  cmp ${params.complexity}  scl ${params.scale.toFixed(1)}`;
      }

      // ‚îÄ‚îÄ Button flash ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      let flashTimer;
      function flashButton(key) {
        const el = document.getElementById('btn-flash');
        el.textContent = key.toUpperCase();
        el.style.opacity = '1';
        clearTimeout(flashTimer);
        flashTimer = setTimeout(() => (el.style.opacity = '0'), 600);
      }

      // ‚îÄ‚îÄ On-screen remote ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      document.querySelectorAll('.rkey[data-key]').forEach((btn) => {
        btn.addEventListener('pointerdown', () => {
          btn.classList.add('pressed');
          sendKey(btn.dataset.key);
        });
        btn.addEventListener('pointerup', () => btn.classList.remove('pressed'));
      });

      // Keyboard mapping
      const KB_MAP = {
        ArrowUp: 'Up',
        ArrowDown: 'Down',
        ArrowLeft: 'Left',
        ArrowRight: 'Right',
        Enter: 'Select',
        Backspace: 'Back',
        Escape: 'Home',
        ' ': 'Play',
        '>': 'Fwd',
        '<': 'Rev',
        '*': 'Info',
        '+': 'VolumeUp',
        '-': 'VolumeDown'
      };
      document.addEventListener('keydown', (e) => {
        const key = KB_MAP[e.key];
        if (key) {
          e.preventDefault();
          sendKey(key);
        }
      });

      // ‚îÄ‚îÄ Canvas ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      const canvas = document.getElementById('c');
      const ctx = canvas.getContext('2d');
      let W,
        H,
        cx,
        cy,
        t = 0;

      function resize() {
        W = canvas.width = window.innerWidth;
        H = canvas.height = window.innerHeight;
        cx = W / 2;
        cy = H / 2;
      }
      window.addEventListener('resize', resize);
      resize();

      // Trail buffer
      let trail = [];
      const MAX_TRAIL = 1800;

      // Particle pool (for particles mode)
      const PARTICLES = Array.from({ length: 120 }, () => ({
        x: 0,
        y: 0,
        vx: 0,
        vy: 0,
        life: 0,
        maxLife: 0,
        hue: 0
      }));

      function resetParticle(p, x, y) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 0.5 + Math.random() * 3;
        p.x = x;
        p.y = y;
        p.vx = Math.cos(angle) * speed;
        p.vy = Math.sin(angle) * speed;
        p.life = 0;
        p.maxLife = 40 + Math.random() * 80;
        p.hue = params.hue;
      }

      // Draw the current shape at time t, return {x, y}
      function shapePt(t) {
        const { mode, complexity: n, scale, speed } = params;
        const s = Math.min(W, H) * 0.38 * scale;
        const st = t * speed;

        switch (mode) {
          case 'lissajous': {
            const a = n,
              b = n + 1;
            return { x: cx + s * Math.sin(a * st + Math.PI / 4), y: cy + s * Math.sin(b * st) };
          }
          case 'rose': {
            const r = s * Math.sin(n * st);
            return { x: cx + r * Math.cos(st), y: cy + r * Math.sin(st) };
          }
          case 'spirograph': {
            const R = s * 0.7,
              r = R / (n + 1),
              d = r * 0.8;
            return {
              x: cx + (R - r) * Math.cos(st) + d * Math.cos(((R - r) / r) * st),
              y: cy + (R - r) * Math.sin(st) - d * Math.sin(((R - r) / r) * st)
            };
          }
          case 'wave': {
            const x = cx + s * Math.sin(st);
            const y = cy + s * Math.sin(n * st + Math.PI / n);
            return { x, y };
          }
          case 'particles': {
            // Just return a point on a circle for particle source
            const r = s * 0.5;
            return { x: cx + r * Math.cos(st), y: cy + r * Math.sin(n * st) };
          }
          default:
            return { x: cx, y: cy };
        }
      }

      // ‚îÄ‚îÄ Render ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      let lastPt = null;

      function frame() {
        requestAnimationFrame(frame);
        t += 0.008;

        const { hue, colorShift, mode } = params;
        const dynHue = colorShift ? (hue + t * 30) % 360 : hue;

        // Fade background
        ctx.fillStyle = 'rgba(5,5,8,0.18)';
        ctx.fillRect(0, 0, W, H);

        const pt = shapePt(t);

        if (mode === 'particles') {
          // Emit particles from shape point
          if (Math.random() < 0.6) {
            const free = PARTICLES.find((p) => p.life >= p.maxLife);
            if (free) resetParticle(free, pt.x, pt.y);
          }
          // Render particles
          for (const p of PARTICLES) {
            if (p.life >= p.maxLife) continue;
            p.life++;
            p.x += p.vx;
            p.y += p.vy;
            p.vy += 0.04; // gravity
            const alpha = 1 - p.life / p.maxLife;
            const size = (1 - p.life / p.maxLife) * 4 + 0.5;
            ctx.beginPath();
            ctx.arc(p.x, p.y, size, 0, Math.PI * 2);
            ctx.fillStyle = `hsla(${dynHue + p.life * 2}, 90%, 65%, ${alpha})`;
            ctx.fill();
          }
          // Draw source dot
          ctx.beginPath();
          ctx.arc(pt.x, pt.y, 6, 0, Math.PI * 2);
          ctx.fillStyle = `hsl(${dynHue}, 100%, 75%)`;
          ctx.shadowColor = `hsl(${dynHue}, 100%, 60%)`;
          ctx.shadowBlur = 20;
          ctx.fill();
          ctx.shadowBlur = 0;
        } else {
          // Trail-based modes
          trail.push({ ...pt, hue: dynHue });
          if (trail.length > MAX_TRAIL) trail.shift();

          // Draw trail as line segments with gradient alpha
          if (trail.length > 2) {
            const len = trail.length;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            for (let i = 1; i < len; i++) {
              const t0 = trail[i - 1],
                t1 = trail[i];
              const progress = i / len;
              const alpha = Math.pow(progress, 1.4) * 0.9;
              const lw = progress * 2.5 + 0.3;
              const h = colorShift ? (t1.hue + progress * 60) % 360 : t1.hue;

              ctx.beginPath();
              ctx.moveTo(t0.x, t0.y);
              ctx.lineTo(t1.x, t1.y);
              ctx.strokeStyle = `hsla(${h}, 85%, 60%, ${alpha})`;
              ctx.lineWidth = lw;
              ctx.stroke();
            }
          }

          // Glowing head
          const grd = ctx.createRadialGradient(pt.x, pt.y, 0, pt.x, pt.y, 14);
          grd.addColorStop(0, `hsla(${dynHue}, 100%, 90%, 1)`);
          grd.addColorStop(0.4, `hsla(${dynHue}, 100%, 65%, 0.6)`);
          grd.addColorStop(1, `hsla(${dynHue}, 100%, 50%, 0)`);
          ctx.beginPath();
          ctx.arc(pt.x, pt.y, 14, 0, Math.PI * 2);
          ctx.fillStyle = grd;
          ctx.fill();
        }

        lastPt = pt;

        // Grid lines (very subtle)
        if (t % 1 < 0.008) {
          // subtle grid pulse on cycle
        }

        // Scanline overlay (every other pixel row, barely visible)
        // (skip for perf ‚Äì handled by CSS layer if desired)
      }

      frame();

      // ‚îÄ‚îÄ Roku Cast Panel ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      const ROKU_CHANNEL_ID = '782875'; // Media Assistant channel
      const ROKU_ECP_PORT = 8060;

      const castToggle = document.getElementById('cast-toggle');
      const castPanel = document.getElementById('cast-panel');
      const castClose = document.getElementById('cast-close');
      const rokuIpInput = document.getElementById('roku-ip-input');
      const mediaUrlInput = document.getElementById('media-url-input');
      const mediaTitleInput = document.getElementById('media-title-input');
      const castSendBtn = document.getElementById('cast-send-btn');
      const castSaveIpBtn = document.getElementById('cast-save-ip');
      const castStatusDot = document.getElementById('cast-status-dot');
      const castStatusText = document.getElementById('cast-status-text');

      // Load saved IP
      const savedRokuIp = localStorage.getItem('rokuIp') || '';
      if (savedRokuIp) {
        rokuIpInput.value = savedRokuIp;
      }

      // Toggle cast panel
      castToggle.onclick = () => {
        castPanel.classList.toggle('visible');
        if (castPanel.classList.contains('visible')) {
          checkRokuConnection();
        }
      };

      castClose.onclick = () => {
        castPanel.classList.remove('visible');
      };

      // Save IP
      castSaveIpBtn.onclick = () => {
        const ip = rokuIpInput.value.trim();
        if (ip) {
          localStorage.setItem('rokuIp', ip);
          setCastStatus('IP saved', 'ok');
          checkRokuConnection();
        }
      };

      // Check Roku connection
      async function checkRokuConnection() {
        const ip = rokuIpInput.value.trim();
        if (!ip) {
          setCastStatus('Not connected', '');
          return;
        }

        try {
          const response = await fetch(`http://${ip}:${ROKU_ECP_PORT}/query/device-info`, {
            method: 'GET',
            mode: 'no-cors'
          });
          // no-cors means we can't read the response, but success means reachable
          setCastStatus('Roku connected', 'ok');
        } catch (err) {
          setCastStatus('Connection failed', 'error');
        }
      }

      function setCastStatus(text, type) {
        castStatusText.textContent = text;
        castStatusDot.className = 'cast-status-dot';
        if (type === 'ok') castStatusDot.classList.add('ok');
        if (type === 'error') castStatusDot.classList.add('error');
      }

      // Cast to Roku
      castSendBtn.onclick = async () => {
        const ip = rokuIpInput.value.trim();
        const mediaUrl = mediaUrlInput.value.trim();
        const title = mediaTitleInput.value.trim() || document.title;

        if (!ip) {
          alert('Please enter Roku IP address');
          return;
        }
        if (!mediaUrl) {
          alert('Please enter media URL');
          return;
        }

        // Build the launch URL with Media Assistant parameters
        const launchUrl = `http://${ip}:${ROKU_ECP_PORT}/launch/${ROKU_CHANNEL_ID}?t=v&u=${encodeURIComponent(mediaUrl)}&videoName=${encodeURIComponent(title)}&videoFormat=hls`;

        try {
          const response = await fetch(launchUrl, {
            method: 'POST',
            mode: 'no-cors',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({})
          });

          setCastStatus('Casting...', 'ok');

          // Log the cast event
          addLogEntry({
            ts: new Date().toISOString(),
            level: 'info',
            message: `Cast to Roku: ${title}`,
            detail: mediaUrl
          });

          // Save to history
          saveCastHistory({ title, url: mediaUrl, date: new Date().toLocaleTimeString() });

          setTimeout(() => {
            setCastStatus('Roku connected', 'ok');
          }, 2000);
        } catch (err) {
          setCastStatus('Cast failed', 'error');
          console.error('Cast error:', err);
        }
      };

      // Auto-fill media URL from current page if it's a video
      function detectMediaUrl() {
        // Look for video elements
        const video = document.querySelector('video');
        if (video && video.src) {
          mediaUrlInput.value = video.src;
        }

        // Look for HLS sources
        const hlsSource = document.querySelector('source[type="application/x-mpegURL"]');
        if (hlsSource && hlsSource.src) {
          mediaUrlInput.value = hlsSource.src;
        }
      }

      // Save cast history
      function saveCastHistory(item) {
        let history = JSON.parse(localStorage.getItem('castHistory') || '[]');
        history = [item, ...history.slice(0, 9)];
        localStorage.setItem('castHistory', JSON.stringify(history));
      }

      // Periodically check for media URLs
      setInterval(detectMediaUrl, 5000);
      detectMediaUrl();
    </script>
  </body>
</html>
